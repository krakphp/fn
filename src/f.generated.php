<?php

/* This file is automatically generated. */
namespace Krak\Fun\f;

// ACCESS
function method($name, $data, ...$optionalArgs)
{
    return $data->{$name}(...$optionalArgs);
}
function prop(string $key, $data, $else = null)
{
    return \property_exists($data, $key) ? $data->{$key} : $else;
}
function index($key, $data, $else = null)
{
    if (\Krak\Fun\isInstance(\ArrayAccess::class, $data)) {
        $exists = $data->offsetExists($key);
    } else {
        $exists = \array_key_exists($key, $data);
    }
    return $exists ? $data[$key] : $else;
}
function setProp(string $key, $value, $data)
{
    $data->{$key} = $value;
    return $data;
}
function setIndex($key, $value, array $data)
{
    $data[$key] = $value;
    return $data;
}
function setIndexIn(array $keys, $value, array $data)
{
    return \Krak\Fun\updateIndexIn($keys, function () use($value) {
        return $value;
    }, $data);
}
function propIn(array $props, $obj, $else = null)
{
    foreach ($props as $prop) {
        if (!\is_object($obj) || !\property_exists($obj, $prop)) {
            return $else;
        }
        $obj = $obj->{$prop};
    }
    return $obj;
}
function indexIn(array $keys, array $data, $else = null)
{
    foreach ($keys as $part) {
        if (!\is_array($data) || !\array_key_exists($part, $data)) {
            return $else;
        }
        $data = $data[$part];
    }
    return $data;
}
function hasIndexIn(array $keys, array $data) : bool
{
    foreach ($keys as $key) {
        if (!\is_array($data) || !\array_key_exists($key, $data)) {
            return false;
        }
        $data = $data[$key];
    }
    return true;
}
function updateIndexIn(array $keys, callable $update, array $data) : array
{
    $curData =& $data;
    foreach (\array_slice($keys, 0, -1) as $key) {
        if (!\array_key_exists($key, $curData)) {
            throw new \RuntimeException('Could not updateIn because the keys ' . \implode(' -> ', $keys) . ' could not be found.');
        }
        $curData =& $curData[$key];
    }
    $lastKey = $keys[count($keys) - 1];
    $curData[$lastKey] = $update($curData[$lastKey] ?? null);
    return $data;
}
// UTILITY
function assign($obj, iterable $iter)
{
    foreach ($iter as $key => $value) {
        $obj->{$key} = $value;
    }
    return $obj;
}
function join(string $sep, iterable $iter)
{
    return \Krak\Fun\reduce(function ($acc, $v) use($sep) {
        return $acc ? $acc . $sep . $v : $v;
    }, $iter, "");
}
function construct($className, ...$args)
{
    return new $className(...$args);
}
function spread(callable $fn, array $data)
{
    return $fn(...$data);
}
function dd($value, callable $dump = null, callable $die = null)
{
    $dump = $dump ?: (function_exists('dump') ? 'dump' : 'var_dump');
    $dump($value);
    ($die ?? function () {
        die;
    })();
}
// SLICING
function takeWhile(callable $predicate, iterable $iter) : iterable
{
    foreach ($iter as $k => $v) {
        if ($predicate($v)) {
            (yield $k => $v);
        } else {
            return;
        }
    }
}
function dropWhile(callable $predicate, iterable $iter) : iterable
{
    $stillDropping = true;
    foreach ($iter as $k => $v) {
        if ($stillDropping && $predicate($v)) {
            continue;
        } else {
            if ($stillDropping) {
                $stillDropping = false;
            }
        }
        (yield $k => $v);
    }
}
function take(int $num, iterable $iter) : iterable
{
    return \Krak\Fun\slice(0, $iter, $num);
}
function drop(int $num, iterable $iter) : iterable
{
    return \Krak\Fun\slice($num, $iter);
}
function slice(int $start, iterable $iter, $length = INF) : iterable
{
    assert($start >= 0);
    $i = 0;
    $end = $start + $length - 1;
    foreach ($iter as $k => $v) {
        if ($start <= $i && $i <= $end) {
            (yield $k => $v);
        }
        $i += 1;
        if ($i > $end) {
            return;
        }
    }
}
function head(iterable $iter)
{
    foreach ($iter as $v) {
        return $v;
    }
}
function chunk(int $size, iterable $iter) : iterable
{
    assert($size > 0);
    $chunk = [];
    foreach ($iter as $v) {
        $chunk[] = $v;
        if (\count($chunk) == $size) {
            (yield $chunk);
            $chunk = [];
        }
    }
    if ($chunk) {
        (yield $chunk);
    }
}
function chunkBy(callable $fn, iterable $iter, ?int $maxSize = null) : iterable
{
    assert($maxSize === null || $maxSize > 0);
    $group = [];
    $groupKey = null;
    foreach ($iter as $v) {
        $curGroupKey = $fn($v);
        $shouldYieldGroup = $groupKey !== null && $groupKey !== $curGroupKey || $maxSize !== null && \count($group) >= $maxSize;
        if ($shouldYieldGroup) {
            (yield $group);
            $group = [];
        }
        $group[] = $v;
        $groupKey = $curGroupKey;
    }
    if (\count($group)) {
        (yield $group);
    }
}
function groupBy(callable $fn, iterable $iter, ?int $maxSize = null) : iterable
{
    return \Krak\Fun\chunkBy($fn, $iter, $maxSize);
}
// GENERATORS
function range($start, $end, $step = null)
{
    if ($start == $end) {
        (yield $start);
    } else {
        if ($start < $end) {
            $step = $step ?: 1;
            if ($step <= 0) {
                throw new \InvalidArgumentException('Step must be greater than 0.');
            }
            for ($i = $start; $i <= $end; $i += $step) {
                (yield $i);
            }
        } else {
            $step = $step ?: -1;
            if ($step >= 0) {
                throw new \InvalidArgumentException('Step must be less than 0.');
            }
            for ($i = $start; $i >= $end; $i += $step) {
                (yield $i);
            }
        }
    }
}
// OPERATORS
function op(string $op, $b, $a)
{
    switch ($op) {
        case '==':
        case 'eq':
            return $a == $b;
        case '!=':
        case 'neq':
            return $a != $b;
        case '===':
            return $a === $b;
        case '!==':
            return $a !== $b;
        case '>':
        case 'gt':
            return $a > $b;
        case '>=':
        case 'gte':
            return $a >= $b;
        case '<':
        case 'lt':
            return $a < $b;
        case '<=':
        case 'lte':
            return $a <= $b;
        case '+':
            return $a + $b;
        case '-':
            return $a - $b;
        case '*':
            return $a * $b;
        case '**':
            return $a ** $b;
        case '/':
            return $a / $b;
        case '%':
            return $a % $b;
        case '.':
            return $a . $b;
        default:
            throw new \LogicException('Invalid operator ' . $op);
    }
}
function andf(callable ...$fns)
{
    return function ($el) use($fns) {
        foreach ($fns as $fn) {
            if (!$fn($el)) {
                return false;
            }
        }
        return true;
    };
}
function orf(callable ...$fns)
{
    return function ($el) use($fns) {
        foreach ($fns as $fn) {
            if ($fn($el)) {
                return true;
            }
        }
        return false;
    };
}
function chain(iterable ...$iters)
{
    foreach ($iters as $iter) {
        foreach ($iter as $k => $v) {
            (yield $k => $v);
        }
    }
}
function zip(iterable ...$iters) : \Iterator
{
    if (count($iters) == 0) {
        return;
    }
    $iters = \array_map(iter::class, $iters);
    while (true) {
        $tup = [];
        foreach ($iters as $iter) {
            if (!$iter->valid()) {
                return;
            }
            $tup[] = $iter->current();
            $iter->next();
        }
        (yield $tup);
    }
}
function flatMap(callable $map, iterable $iter) : iterable
{
    foreach ($iter as $k => $v) {
        foreach ($map($v) as $k => $v) {
            (yield $k => $v);
        }
    }
}
function flatten(iterable $iter, $levels = INF) : iterable
{
    if ($levels == 0) {
        yield from $iter;
    } else {
        if ($levels == 1) {
            foreach ($iter as $k => $v) {
                if (\is_iterable($v)) {
                    foreach ($v as $k1 => $v1) {
                        (yield $k1 => $v1);
                    }
                } else {
                    (yield $k => $v);
                }
            }
        } else {
            foreach ($iter as $k => $v) {
                if (\is_iterable($v)) {
                    foreach (flatten($v, $levels - 1) as $k1 => $v1) {
                        (yield $k1 => $v1);
                    }
                } else {
                    (yield $k => $v);
                }
            }
        }
    }
}
function product(iterable ...$iters) : iterable
{
    if (count($iters) === 0) {
        yield from [];
        return;
    }
    if (count($iters) === 1) {
        yield from \Krak\Fun\map(function ($v) {
            return [$v];
        }, $iters[0]);
        return;
    }
    foreach ($iters[0] as $value) {
        yield from \Krak\Fun\map(function (array $tup) use($value) {
            array_unshift($tup, $value);
            return $tup;
        }, \Krak\Fun\product(...\array_slice($iters, 1)));
    }
}
function when(callable $if, callable $then, $value)
{
    return $if($value) ? $then($value) : $value;
}
function toPairs(iterable $iter) : iterable
{
    foreach ($iter as $key => $val) {
        (yield [$key, $val]);
    }
}
function fromPairs(iterable $iter) : iterable
{
    foreach ($iter as list($key, $val)) {
        (yield $key => $val);
    }
}
function pick(iterable $fields, array $data) : array
{
    $pickedData = [];
    foreach ($fields as $field) {
        $pickedData[$field] = $data[$field] ?? null;
    }
    return $pickedData;
}
function pickBy(callable $pick, array $data) : array
{
    $pickedData = [];
    foreach ($data as $key => $value) {
        if ($pick([$key, $value])) {
            $pickedData[$key] = $value;
        }
    }
    return $pickedData;
}
function within(array $fields, iterable $iter) : \Iterator
{
    return \Krak\Fun\filterKeys(\Krak\Fun\Curried\inArray($fields), $iter);
}
function without(array $fields, iterable $iter) : \Iterator
{
    return \Krak\Fun\filterKeys(\Krak\Fun\Curried\not(\Krak\Fun\Curried\inArray($fields)), $iter);
}
function compact(iterable $iter) : iterable
{
    foreach ($iter as $key => $val) {
        if ($val !== null) {
            (yield $key => $val);
        }
    }
}
function arrayCompact(iterable $iter) : array
{
    $vals = [];
    foreach ($iter as $key => $val) {
        if ($val !== null) {
            $vals[$key] = $val;
        }
    }
    return $vals;
}
function pad(int $size, iterable $iter, $padValue = null) : iterable
{
    $i = 0;
    foreach ($iter as $key => $value) {
        (yield $value);
        $i += 1;
    }
    if ($i >= $size) {
        return;
    }
    foreach (\Krak\Fun\range($i, $size - 1) as $index) {
        (yield $padValue);
    }
}
// ALIASES
function inArray(array $set, $item) : bool
{
    return \in_array($item, $set);
}
function arrayMap(callable $fn, iterable $data) : array
{
    return \array_map($fn, \is_array($data) ? $data : \Krak\Fun\toArray($data));
}
function arrayFilter(callable $fn, iterable $data) : array
{
    return \array_filter(\is_array($data) ? $data : \Krak\Fun\toArray($data), $fn);
}
function all(callable $predicate, iterable $iter) : bool
{
    foreach ($iter as $key => $value) {
        if (!$predicate($value)) {
            return false;
        }
    }
    return true;
}
function any(callable $predicate, iterable $iter) : bool
{
    foreach ($iter as $key => $value) {
        if ($predicate($value)) {
            return true;
        }
    }
    return false;
}
function search(callable $predicate, iterable $iter)
{
    foreach ($iter as $value) {
        if ($predicate($value)) {
            return $value;
        }
    }
}
function indexOf(callable $predicate, iterable $iter)
{
    foreach ($iter as $key => $value) {
        if ($predicate($value)) {
            return $key;
        }
    }
}
function trans(callable $trans, callable $fn, $data)
{
    return $fn($trans($data));
}
function not(callable $fn, ...$args) : bool
{
    return !$fn(...$args);
}
function isInstance($class, $item)
{
    return $item instanceof $class;
}
function isNull($val)
{
    return \is_null($val);
}
function nullable(callable $fn, $value)
{
    return $value === null ? $value : $fn($value);
}
function partition(callable $partition, iterable $iter, int $numParts = 2) : array
{
    $parts = \array_fill(0, $numParts, []);
    foreach ($iter as $val) {
        $index = (int) $partition($val);
        $parts[$index][] = $val;
    }
    return $parts;
}
function map(callable $predicate, iterable $iter) : iterable
{
    foreach ($iter as $key => $value) {
        (yield $key => $predicate($value));
    }
}
function mapKeys(callable $predicate, iterable $iter) : iterable
{
    foreach ($iter as $key => $value) {
        (yield $predicate($key) => $value);
    }
}
function mapKeyValue(callable $fn, iterable $iter) : iterable
{
    foreach ($iter as $key => $value) {
        [$key, $value] = $fn([$key, $value]);
        (yield $key => $value);
    }
}
function mapOn(array $maps, iterable $iter) : iterable
{
    foreach ($iter as $key => $value) {
        if (isset($maps[$key])) {
            (yield $key => $maps[$key]($value));
        } else {
            (yield $key => $value);
        }
    }
}
function mapAccum(callable $fn, iterable $iter, $acc = null)
{
    $data = [];
    foreach ($iter as $key => $value) {
        [$acc, $value] = $fn($acc, $value);
        $data[] = $value;
    }
    return [$acc, $data];
}
function withState(callable $fn, $initialState = null)
{
    $state = $initialState;
    return function (...$args) use($fn, &$state) {
        [$state, $res] = $fn($state, ...$args);
        return $res;
    };
}
function arrayReindex(callable $fn, iterable $iter) : array
{
    $res = [];
    foreach ($iter as $key => $value) {
        $res[$fn($value)] = $value;
    }
    return $res;
}
function reindex(callable $fn, iterable $iter) : iterable
{
    foreach ($iter as $key => $value) {
        (yield $fn($value) => $value);
    }
}
function reduce(callable $reduce, iterable $iter, $acc = null)
{
    foreach ($iter as $key => $value) {
        $acc = $reduce($acc, $value);
    }
    return $acc;
}
function reduceKeyValue(callable $reduce, iterable $iter, $acc = null)
{
    foreach ($iter as $key => $value) {
        $acc = $reduce($acc, [$key, $value]);
    }
    return $acc;
}
function filter(callable $predicate, iterable $iter) : iterable
{
    foreach ($iter as $key => $value) {
        if ($predicate($value)) {
            (yield $key => $value);
        }
    }
}
function filterKeys(callable $predicate, iterable $iter) : iterable
{
    foreach ($iter as $key => $value) {
        if ($predicate($key)) {
            (yield $key => $value);
        }
    }
}
function values(iterable $iter) : iterable
{
    foreach ($iter as $v) {
        (yield $v);
    }
}
function keys(iterable $iter) : iterable
{
    foreach ($iter as $k => $v) {
        (yield $k);
    }
}
function flip(iterable $iter) : iterable
{
    foreach ($iter as $k => $v) {
        (yield $v => $k);
    }
}
function curry(callable $fn, int $num = 1)
{
    if ($num == 0) {
        return $fn;
    }
    return function ($arg1) use($fn, $num) {
        return curry(function (...$args) use($fn, $arg1) {
            return $fn($arg1, ...$args);
        }, $num - 1);
    };
}
function placeholder()
{
    static $v;
    $v = $v ?: new class
    {
    };
    return $v;
}
function _()
{
    return placeholder();
}
function partial(callable $fn, ...$appliedArgs)
{
    return function (...$args) use($fn, $appliedArgs) {
        list($appliedArgs, $args) = \array_reduce($appliedArgs, function ($acc, $arg) {
            list($appliedArgs, $args) = $acc;
            if ($arg === \Krak\Fun\placeholder()) {
                $arg = array_shift($args);
            }
            $appliedArgs[] = $arg;
            return [$appliedArgs, $args];
        }, [[], $args]);
        return $fn(...$appliedArgs, ...$args);
    };
}
function autoCurry(array $args, $numArgs, callable $fn)
{
    if (\count($args) >= $numArgs) {
        return $fn(...$args);
    }
    if (\count($args) == $numArgs - 1) {
        return \Krak\Fun\partial($fn, ...$args);
    }
    if (\count($args) == 0) {
        return \Krak\Fun\curry($fn, $numArgs - 1);
    }
    return \Krak\Fun\curry(\Krak\Fun\partial($fn, ...$args), $numArgs - 1 - \count($args));
}
function toArray(iterable $iter) : array
{
    $data = [];
    foreach ($iter as $key => $val) {
        $data[] = $val;
    }
    return $data;
}
function toArrayWithKeys(iterable $iter) : array
{
    $data = [];
    foreach ($iter as $key => $val) {
        $data[$key] = $val;
    }
    return $data;
}
function id($v)
{
    return $v;
}
// UTILITY
function differenceWith(callable $cmp, iterable $a, iterable $b)
{
    return \Krak\Fun\filter(function ($aItem) use($cmp, $b) {
        return \Krak\Fun\indexOf(\Krak\Fun\partial($cmp, $aItem), $b) === null;
    }, $a);
}
function sortFromArray(callable $fn, array $orderedElements, iterable $iter) : array
{
    $data = [];
    $flippedElements = \array_flip($orderedElements);
    foreach ($iter as $value) {
        $key = $fn($value);
        if (!\array_key_exists($key, $flippedElements)) {
            throw new \LogicException('Cannot sort element key ' . $key . ' because it does not exist in the ordered elements.');
        }
        $data[$flippedElements[$key]] = $value;
    }
    ksort($data);
    return $data;
}
function retry(callable $fn, $shouldRetry = null)
{
    if (\is_null($shouldRetry)) {
        $shouldRetry = function ($numRetries, \Throwable $t = null) {
            return true;
        };
    }
    if (\is_int($shouldRetry)) {
        $maxTries = $shouldRetry;
        if ($maxTries < 0) {
            throw new \LogicException("maxTries must be greater than or equal to 0");
        }
        $shouldRetry = function ($numRetries, \Throwable $t = null) use($maxTries) {
            return $numRetries <= $maxTries;
        };
    }
    if (!\is_callable($shouldRetry)) {
        throw new \InvalidArgumentException('shouldRetry must be an int or callable');
    }
    $numRetries = 0;
    do {
        try {
            return $fn($numRetries);
        } catch (\Throwable $t) {
        }
        $numRetries += 1;
    } while ($shouldRetry($numRetries, $t));
    throw $t;
}
function pipe(callable ...$fns)
{
    return function (...$args) use($fns) {
        $isFirstPass = true;
        foreach ($fns as $fn) {
            if ($isFirstPass) {
                $arg = $fn(...$args);
                $isFirstPass = false;
            } else {
                $arg = $fn($arg);
            }
        }
        return $arg;
    };
}
function compose(callable ...$fns)
{
    return \Krak\Fun\pipe(...\array_reverse($fns));
}
function stack(array $funcs, callable $last = null, callable $resolve = null)
{
    return function (...$args) use($funcs, $resolve, $last) {
        return \Krak\Fun\reduce(function ($acc, $func) use($resolve) {
            return function (...$args) use($acc, $func, $resolve) {
                $args[] = $acc;
                $func = $resolve ? $resolve($func) : $func;
                return $func(...$args);
            };
        }, $funcs, $last ?: function () {
            throw new \LogicException('No stack handler was able to capture this request');
        });
    };
}
function each(callable $handle, iterable $iter)
{
    foreach ($iter as $v) {
        $handle($v);
    }
}
/** @deprecated */
function onEach(callable $handle, iterable $iter)
{
    foreach ($iter as $v) {
        $handle($v);
    }
}
function iter($iter) : \Iterator
{
    if (\is_array($iter)) {
        return new \ArrayIterator($iter);
    } else {
        if ($iter instanceof \Iterator) {
            return $iter;
        } else {
            if (\is_object($iter) || \is_iterable($iter)) {
                return (function ($iter) {
                    foreach ($iter as $key => $value) {
                        (yield $key => $value);
                    }
                })($iter);
            } else {
                if (\is_string($iter)) {
                    return (function ($s) {
                        for ($i = 0; $i < \strlen($s); $i++) {
                            (yield $i => $s[$i]);
                        }
                    })($iter);
                }
            }
        }
    }
    throw new \LogicException('Iter could not be converted into an iterable.');
}